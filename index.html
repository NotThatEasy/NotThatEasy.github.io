<!DOCTYPE html>
<html>
    <head>

        <script src="scripts/twomin.js">
            
        </script>

        <script src = "scripts/page.js"></script>
        <title>pet proj</title>

    </head>
    <body>

        <script>
        
            let fieldSize = 660;
            let outlineWidth = 5;
            let elementSize = fieldSize + outlineWidth * 2;
            
            let field_xbyx = 5;
            
            let tileSize = 100;
            let gap = 15;
            
            let step = tileSize + gap;
            
            let margin = (elementSize - tileSize * field_xbyx - gap * (field_xbyx - 1) ) / 2 + tileSize / 2;

            let color0 = {r: 245, g: 222, b: 179};
            let color1 = {r: 139, g: 0, b: 0};
            let r_diff = (color0.r - color1.r) / 7;
            let g_diff = (color0.g - color1.g) / 7;
            let b_diff = (color0.b - color1.b) / 7;
            let counter = 0;

            let colormap_tile = {2: 'blanchedalmond', 4: 'wheat', 8: 'rgb(231, 194,156)', 16: 'rgb(218,166,134)', 32: 'rgb(205,145,115)', 64: 'rgb(192,130,90)'
                , 128: 'rgb(175,115,75)', 256: 'rgb(190,120,30)', 512: 'rgb(210,130,30)', 1024: 'rgb(130, 50, 50)', 2048: 'rgb(120, 30, 30)'};
            //let colormap_text = {2: '', 4: '', 8: '', 16: '', 32: '', 64: '', 128: '', 256: '', 512: '', 1024: '', 2048: ''};
            
            function msToFrames(milliseconds)
            {
                return Math.floor(60 * milliseconds / 1000);
            };

            //Class for storing 2-vectors conveniently
            class Point{
                constructor(x, y)
                {
                    this.x = x;
                    this.y = y;
                }
            }
    
            class Field{
                constructor(space)
                {

                    //Defining drawing space
                    this.space = space;
                    
                    
                    //Defining background game field
                    this._field = this.space.makeRoundedRectangle(fieldSize / 2 + outlineWidth, fieldSize / 2 + outlineWidth
                    , fieldSize, fieldSize, fieldSize / 20);
                    this._field._fill = 'rgb(225,240,240)';
                    this._field._linewidth = outlineWidth;
                    this._field._stroke = 'darkcyan';
                    
                    this.tileSprites = [];
                    for(let i = 0; i < field_xbyx * field_xbyx; ++i){

                        this.tileSprites[i] = (this.space.makeRoundedRectangle(i % 5 * step + margin, Math.floor(i / 5) * step + margin
                            , tileSize, tileSize, 7));
                        this.tileSprites[i].fill = 'rgb(127,200,170)';
                        this.tileSprites[i].stroke = 'rgb(225,240,240)';
                    }

                    
                    //Creating tile
                    this.tiles = [];
                    for(let i = 0; i < field_xbyx * field_xbyx; ++i){

                        this.tiles[i] = null;
                    }
                    
                    for(let i = 0; i < 2; ++i){

                        let current = null;
                        do{
                            current = Math.floor(Math.random() * field_xbyx * field_xbyx);
                        }
                        while(/*current % 5 == 0 || current % 5 == 4 || Math.floor(current / 5) == 0 || Math.floor(current / 5) == 4 ||*/ 
                        this.tiles[current] !== null);

                        this.tiles[current] = new Tile(current, this.space);
                    }

                    

                }


                /*
                 * Method to move the tiles on user input
                 */
                move(horizontal, vertical)
                {
                    //Time of the animation after which new tile can be spawned
                    let maxTime = 0;
                    //"Current" tile is the tile decisions and computations are made relative to
                    let current;
                    if(horizontal < 0 || vertical < 0){
                        current = 0;
                    }
                    else {current = 24;}
                    
                    //Finding the first non-null tile 
                    while(this.tiles[current] === null){
                        current -= horizontal + vertical;
                    }
                    //Process the tiles until it turns out next one would be out of range. This marks all tiles have been processed
                    while(this.tiles[current] !== undefined){
                        //Move to the next tile in the parameter specified direction until the selected tile is not empty or out of field borders.
                        let target = current;
                        do{
                            target += horizontal + vertical * 5;
                        }
                        while(this.tiles[target] === null && 
                        (target % 5 === current % 5 && horizontal === 0 
                        || Math.floor(target / 5) === Math.floor(current / 5) && vertical === 0));

                        
                        //Revert the target one tile back against the parameter specified direction and move to the new target
                        tile_logic: if(
                        //If the tile is out of range or is not on the same row/column as the tile logic intends to move
                        typeof this.tiles[target] == 'undefined' || !(target % 5 === current % 5 && horizontal === 0 || Math.floor(target / 5) === Math.floor(current / 5) && vertical === 0) 
                        //otherwise, in case value of not-null target is not the same as the one logic intends to move 
                        || (this.tiles[current].value === this.tiles[target].value ? false : true)
                        //lastly, if target tile has been merged during this move
                        || this.tiles[target].merged){

                            //Move the target tile one position back
                            target -= horizontal + vertical * 5;
                            //There should be no need to process and animate tiles given that target tile is the same as the one to move
                            if(target === current)
                                break tile_logic;

                            
                            /*100 ms basic animation length + 50 ms per each tile between the original tile and position tile is moved to*/
                            let animation_duration = 100 + ((Math.abs(target - current) % 5 == 0 ? Math.abs(target - current) / 5 : Math.abs(target - current) % 5) - 1) * 50;
                            
                            //Making the target tile have all the same values as current one and replacing the current tile with null 
                            [this.tiles[target], this.tiles[current]] = [this.tiles[current], this.tiles[target]];

                            this.tiles[target].animate_movement(new Point(margin + step * (target % 5), margin + step * (Math.floor(target / 5)))
                                
                                , msToFrames(animation_duration));

                            
                            //Updating the time needed to pass before spawning a new tile
                            if(animation_duration > maxTime){
                                maxTime = animation_duration;
                            }
                       }
                        

                        //Moving to and merging with the target tile
                        else if(this.tiles[current].value === this.tiles[target].value){

                            /*50 ms basic animation length + 50 ms per each tile between the original tile and position tile is moved to*/
                            let animation_duration = 75 + ((Math.abs(target - current) % 5 == 0 ? Math.abs(target - current) / 5 : Math.abs(target - current) % 5) - 1) * 50;
                            
                            
                            //Removing the current tile from the field while still animating it
                            let disconnect = null;
                            [this.tiles[current], disconnect] = [disconnect, this.tiles[current]];
                            (disconnect).animate_movement(new Point(margin + step * (target % 5), margin + step * (Math.floor(target / 5)))
                            , msToFrames(animation_duration), true);
                            
                            
                            //as well as double the target tile value and animate it with merging animation
                            this.tiles[target].value *= 2;
                            this.tiles[target].merging = true;
                            this.tiles[target].merged = true;
                            setTimeout(()=>{
                                try{
                                    this.tiles[target].animate_merge(msToFrames(100));
                                }
                                catch(error){
                                    console.dir(error);
                                }
                                
                            }, animation_duration);


                            //Update the time needed to pass before spawning a new tile
                            if(animation_duration > maxTime)
                                maxTime = animation_duration + 100;
                        }
                        //Searching for the next tile
                        do{
                            current -= horizontal + vertical;
                        }
                        while(this.tiles[current] === null);

                    }
                    //Resetting the tiles that have been merged on the current move
                    for(let each of this.tiles)
                        if(each !== null)
                            each.merged = false;
                    
                    switch(this.is_game_over()){
                        case 1:

                            break;
                        case 0: 
                            let context = this;
                            if(maxTime !== 0){
                                setTimeout(function(){ context.spawn_tile(msToFrames(100)); }, maxTime);                                
                            }
                                
                            break;
                        case -1: 
                            break;

                    }

                    this.space.play();
                    //setTimeout(space.pause, maxTime + 100);
                    
                }
                

                is_game_over()
                {
                    for(let each of this.tiles)
                        if(each !== null && each.value === 2048)
                        {
                            each.animate_gameover();
                            return 1;
                        }
                    if(this.full()){
                        if(this.no_moves()){
                            return -1;
                        }
                    }
                    return 0;
                }

                no_moves()
                {
                    let passed = [];
                    
                    function ok(context, one, another)
                    {
                        if(typeof context.tiles[another] !== 'undefined'){
                            if(context.tiles[one] === context.tiles[another]){
                                return true;
                            }
                        }
                        return false;
                    }

                    for(let i = 0; i < 25; ++i){
                        if(ok(this, i, i-1) || ok(this, i, i + 1) || ok(this, i, i - field_xbyx) || ok(this, i, i + field_xbyx)){
                            return false;
                        }
                    }
                    return true;
                }


                //Method to check if the field is filled with tiles completely
                full()
                {
                    for(const any of this.tiles)
                        if(any === null)
                            return false;
                    return true;
                }


                //Method to check if any of the field's tiles are animated
                animated()
                {
                    for(const any of this.tiles)
                        if(any !== null && (any.moving || any.merging || any.gameovering || any.spawning))
                            return true;
                    return false;
                }

                //Create a new tile on the field by selecting a random non-filled tile and creating a new one there
                spawn_tile(frames)
                {
                    let current = null;
                    do{
                        current = Math.floor(Math.random() * 25);
                    }
                    while(this.tiles[current] !== null);
                    this.tiles[current] = new Tile(current, this.space);
                    this.tiles[current].sprite.scale = 0;
                    this.tiles[current].spawning = true;

                    let context = this;
                    let frameStep = 1 / frames;
                    let spawner = function(){

                        if(frames === 0){
                            context.tiles[current].sprite.scale = 1;
                            context.space.unbind('update', spawner);
                            context.space.update();
                            context.tiles[current].spawning = false;
                        }
                        else{
                            --frames;
                            context.tiles[current].sprite.scale += frameStep;
                        }
                    };
                    this.space.bind('update', spawner);
                }
            };


            class Tile{
                constructor(position, space)
                {
                    this.value = 2;
                    let coords = {x: position % 5 * step + margin, y: Math.floor(position / 5) * step + margin};
                    //Defining drawing space
                    this.space = space;
                    
                    //Defining tile sprite
                    this.sprite = space.makeRoundedRectangle(coords.x, coords.y, tileSize, tileSize);
                    this.sprite.fill = colormap_tile[this.value];
                    this.sprite.stroke = colormap_tile[this.value];

                    //Defining the value displayed over the tile
                    this.message = this.space.makeText(this.value, coords.x, coords.y);
                    this.message.fill = 'teal';
                    this.message.size = 40;
                    
                    //Extra flags for the movement logic
                    this.moving = false;
                    this.merging = false;
                    this.merged = false;
                    this.gameovering = false;
                    this.spawning = false;

                }

                //
                animate_gameover()
                {
                    let context = this;
                    //
                    //this.final = true;
                    //
                    this.gameovering = true;
                    let frameChange = 0.05;
                    let gameover = function()
                    {
                        if(typeof context.final !== 'undefined' && context.final){
                            context.space.unbind('update', gameover);
                            context.moving = false;
                            context.gameovering = false;
                            context.merging = false;

                        }
                        else{
                            context.message.rotation += frameChange;

                        } 
                    };
                    context.space.bind('update', gameover);
                }

                //Animation of tile merging
                animate_merge(framesCount)
                {
                    let context = this;
                    let threshold = Math.round(framesCount / 2);
                    let frameChange = 0.2 / framesCount * 2;
                    this.merging = true;
                    let merge = function(){
                            if(framesCount === 0)
                        {
                            --framesCount;
                            context.sprite.scale = 1;
                            context.message.scale = 1;
                            context.space.unbind('update', merge);
                            context.merging = false;
                        }
                        else{
                            if(framesCount > threshold){
                                context.sprite.scale = context.sprite.scale + frameChange;
                                context.message.scale = context.message.scale + frameChange * 2;
                            }
                            else{
                                context.update();
                                context.sprite.scale = context.sprite.scale - frameChange;
                                context.message.scale = context.message.scale - frameChange * 2;
                            }
                                
                            
                            --framesCount;
                            
                        }
                    }
                    context.space.bind('update', merge);
                }
                destroy()
                {
                    this.space = undefined;
                    this.sprite = undefined;
                    this.value = undefined;
                    this.message = undefined;
                }
                animate_movement(moveTo, framesCount, flag)
                {
                    let frameStep = { x: (moveTo.x - this.sprite.translation.x) / framesCount, y: (moveTo.y - this.sprite.translation.y) / framesCount };
                    let context = this;
                    this.moving = true;
                    let f = function()
                    {
                        if(framesCount === 0){
                            --framesCount;
                            context.sprite.translation.set(moveTo.x, moveTo.y);
                            context.message.translation.set(moveTo.x, moveTo.y);
                            context.space.unbind('update', f);
                            //Not sure this needs to be updated
                            context.moving = false;
                            
                            
                            if(typeof(flag) !== 'undefined'/* && flag*/){
                                context.sprite.remove();
                                context.message.remove();
                                context.destroy();
                            }
                        }
                        else if(framesCount > 0){
                            --framesCount;
                            context.sprite.translation.set(context.sprite.translation.x + frameStep.x, context.sprite.translation.y + frameStep.y);
                            context.message.translation.set(context.sprite.translation.x + frameStep.x, context.sprite.translation.y + frameStep.y);
                        }
                    };
                    this.space.bind('update', f);

                }
                update()
                {
                    this.message.value = this.value;
                    this.sprite.fill = colormap_tile[this.value];
                    this.sprite.stroke = colormap_tile[this.value];
                }

            };
    
    
        </script>
        <div class="cont">
            
            <div class="topnav">
                <a class="active barButton" href="">Home</a>

                <a class="barButton" href="">News</a>

                <a class="barButton" href="">Contact</a>

                <a class="barButton" href="">About</a>
            </div>
            <div id="draw">
                <script>

                    
                    let space = new Two( { width: elementSize, height: elementSize, type: Two.Types.webgl} )
                        
                        .appendTo(document.getElementById('draw'));


                    let field = new Field(space);

                    let a0 = space.makeRoundedRectangle(100, 100, 100, 100, 20);
                    a0.translation.set(-100, -100);
                    a0 = undefined;

                    space.update();
                    //space.play();
                    let a = [[0,1], [1, 0], [0, -1], [-1, 0]];

                    function func()
                    {
                        return Math.round(Math.random() * 3);
                    }

                    var btn = document.createElement("BUTTON");   // Create a <button> element
                    btn.innerHTML = "CLICK ME";                   // Insert text
                    document.getElementById('draw').append(btn);
                    //btn.
                    space.bind('update', function(){
                        let x = func();
                        if(field.animated())
                            ;
                        else
                            field.move(a[x][0], a[x][1]);
                            ;
                    })

                    window.addEventListener('click', function(){
                        let x = func();
                        //field.move(a[x][0], a[x][1]);
                    });
                    
                    window.addEventListener('keydown', function(event){
                        switch(event.keyCode){
                            case 37: 
                                //left;
                                if(field.animated())
                                    ;
                                else
                                    field.move(-1, 0);
                                break;
                            case 38: 
                                //up;
                                if(field.animated())
                                    ;
                                else
                                    field.move(0, -1);
                                break;
                            case 39:
                                //right;
                                if(field.animated())
                                    ;
                                else
                                    field.move(1, 0);
                                break;
                            case 40:
                                //down;
                                if(field.animated())
                                    ;
                                else
                                    field.move(0, 1);
                                break;
                            default:
                                break;
                        }
                    });
                </script>
            </div>
        <style>
            /* Add a black background color to the top navigation */
            .topnav {
            background-color: #333;
            overflow: hidden;
            }

            /* Style the links inside the navigation bar */
            .topnav a {
            float: left;
            color: #f2f2f2;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none;
            font-size: 17px;
            }

            /* Change the color of links on hover */
            .topnav a:hover {
            background-color: #ddd;
            color: black;
            }

            /* Add a color to the active/current link */
            .topnav a.active {
            background-color: #4CAF50;
            color: white;
            }
            #draw111 {
                width: 660px;
                height: 660px;
                border-radius: 7%;
                border: 10px solid darkcyan;
                background: ivory;
            }
        </style>
        </div>
    </body>
</html>

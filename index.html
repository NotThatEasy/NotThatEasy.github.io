<!DOCTYPE html>
<html>
    <head>

        <script  src = "scripts/twomin.js">
        </script>
        <style>
            @font-face {
                font-family: Leelawadee;
                src: url("LeelawUI.ttf");
            }
            *{
                font-family: Leelawadee, Verdana, Tahoma;
            }
            .noselect {
                -webkit-user-select: none; /* Safari */
                -moz-user-select: none; /* Old versions of Firefox */
                -ms-user-select: none; /* Internet Explorer/Edge */
                user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome, Opera and Firefox */
            }
            .bottom_nav {
                animation: rev_accordeon 650ms;
                bottom: 0;
                width: 100%;
                padding-top: 0.25%;
                position: fixed;
                background-color: #333;
                outline-style: solid;
                outline-color: #529ed6;
            }
            body{
                margin: 0;
                overflow: auto;
                background-color: #1e1e1e;
                color: white;
            }
            .container{
                
                /*position: absolute;
                margin: auto;*/
            }
            .topnav {
                animation: accordeon 650ms;
                background-color: #333;
                outline-style: solid;
                outline-width: 3px;
                outline-color: #529ed6;
                overflow: hidden;
            }
            
            .barButton {
                float: left;
                background-color: inherit;
                border: none;
                outline: none;
                cursor: pointer;
                color: azure;
                text-align: center;
                padding: 1vh 3%;
                transition: 250ms;
                font-size: 17px;
                margin-right: 1%;
            }
            .content {
                padding: 0% 15% 10% 10%;
                animation: fadeSlideIn 500ms;
            }
            #game {
                padding: 15px 0px 0px;
            }
            .right-slided {
                float: right;
                animation: slide_right 500ms;
            }            
            .barButton.active {
            background-color: #529ed6;
            animation: accordeon_horizontal 0.4s;
            animation-iteration-count: 1;
            color: white;
            }
            
            .barButton:hover {
            background-color: lightgray;
            color: black;
            transform: scale(1.2);
            }
            .out {
                animation: fadeSlideOut 400ms;
            }
            .bottom_out {
                animation: accordeon_out 500ms;
            }
            .green {
                color: #4acbb5;
            }
            .blue {
                color: #529ed6;
            }
            #home, #eng {
                counter-reset: line;
            }
            #home > div:before,
            #home > span:before,
            #eng > div:before,
            #eng > span:before {
                counter-increment: line;
                content: counter(line);
            }
            @keyframes accordeon {
                from{transform: translate(0%, -200%);}
                to{transform: translate(0%, 0%)}
            }
            @keyframes accordeon_out {
                from{}
                to{transform: translate(0%, 200%);}
            }
            @keyframes rev_accordeon {
                from{transform: translate(0%, 200%);}
                to{}
            }
            
            /* Go from zero to full opacity */
            @keyframes fadeSlideIn {
                from {transform: translate(-180%, 0%);opacity: 0;}
                to {opacity: 1;}
            }
            @keyframes fadeSlideOut {
                from {opacity: 1;}
                to {transform: translate(180%, 0%); opacity: 0;}
            }            
        </style>

        <title>Резюме</title>

    </head>
    <body>

        <script>
            //Beginning of definitive script section
            let width  = document.documentElement.clientWidth || document.body.clientWidth || window.innerWidth;
            let height = document.documentElement.clientHeight || document.body.clientHeight || window.innerHeight;
            console.log(width, height);

            let available_space = width > height ? height : width;
            let field_xbyx = 5;

            let tileSize = Math.floor(Math.floor(available_space / field_xbyx / 1.5) / 6) * 6;
            
            
            let fieldSize = Math.ceil((available_space - Math.floor(available_space / 6)) / 10) * 10;
            let outlineWidth = 5;
            
            
            let gap = 15;

            let elementSize = fieldSize + outlineWidth * 2;
            let step = tileSize + gap;
            
            let margin = (elementSize - tileSize * field_xbyx - gap * (field_xbyx - 1) ) / 2 + tileSize / 2;


            function setDimensions(xbyx)
            {
                
                width  = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
                height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
                available_space = width > height ? height : width;
                field_xbyx = xbyx;
                tileSize = Math.floor(Math.floor(available_space / field_xbyx / 1.5) / 6) * 6;
                fieldSize = Math.ceil((available_space - Math.floor(available_space / 6)) / 10) * 10;
                elementSize = fieldSize + outlineWidth * 2;
                step = tileSize + gap;
                margin = (elementSize - tileSize * field_xbyx - gap * (field_xbyx - 1) ) / 2 + tileSize / 2;
            }

            let colormap_tile = {2: 'blanchedalmond', 4: 'wheat', 8: 'rgb(231, 194,156)', 16: 'rgb(218,166,134)', 32: 'rgb(205,145,115)', 64: 'rgb(192,130,90)'
                , 128: 'rgb(175,115,75)', 256: 'rgb(190,120,30)', 512: 'rgb(210,130,30)', 1024: 'rgb(130, 50, 50)', 2048: 'rgb(120, 30, 30)'};
            
            
            
    
            //Function to convert milliseconds to specific number of frames assuming animation is 60 fps
            function msToFrames(milliseconds)
            {
                return Math.floor(60 * milliseconds / 1000);
            };

            //Class for storing 2-vectors conveniently
            class Point{
                constructor(x, y)
                {
                    this.x = x;
                    this.y = y;
                }
            };
    
            class Field{
                constructor(space)
                {

                    //Copying drawing space
                    this.space = space;
                    
                    
                    //Defining background game field
                    this._field = this.space.makeRoundedRectangle(fieldSize / 2 + outlineWidth, fieldSize / 2 + outlineWidth
                    , fieldSize, fieldSize, fieldSize / 20);
                    this._field._fill = 'rgb(225,240,240)';
                    this._field._linewidth = outlineWidth;
                    this._field._stroke = 'darkcyan';
                    
                    this.tileSprites = [];
                    for(let i = 0; i < field_xbyx * field_xbyx; ++i){

                        this.tileSprites[i] = 
                            (this.space.makeRoundedRectangle(Math.round(i % field_xbyx * step + margin)
                            , Math.round(Math.floor(i / field_xbyx) * step + margin)
                            , tileSize, tileSize));
                        this.tileSprites[i].fill = 'darkcyan';
                        this.tileSprites[i].stroke = 'rgb(225,240,240)';
                    }
                    
                    //Creating tile
                    this.tiles = [];
                    for(let i = 0; i < field_xbyx * field_xbyx; ++i){

                        this.tiles[i] = null;
                    }
                    
                    for(let i = 0; i < 2; ++i){

                        let current = null;
                        do{
                            current = Math.floor(Math.random() * field_xbyx * field_xbyx);
                        }
                        while(/*current % field_xbyx == 0 || current % field_xbyx == 4 || Math.floor(current / field_xbyx) == 0 || Math.floor(current / field_xbyx) == 4 ||*/ 
                        this.tiles[current] !== null);
                        
                        this.tiles[current] = new Tile(current, this.space);
                    }
                    
                    this.keyListener = null;
                    
                    this.attach_keyboard_controls();
                    this.attach_touch_controls();
                }


                //Method utilized to add controls to the in-game tiles and to make the game play itself
                attach_keyboard_controls()
                {
                    let context = this;
                    let LEFT = 37, RIGHT = 39, UP = 38, DOWN = 40;
                    let ENTER = 13;
                    this.keyListener = function(event){
                        if(document.getElementById('game').style.display === 'none')
                            return;

                        switch(event.keyCode){
                            case ENTER:
                                if(autoplaying){
                                    autoplaying = false;
                                    space.unbind('update', auto);
                                }
                                else{
                                    autoplaying = true;
                                    space.bind('update', auto);
                                    space.play();
                                }
                                break;
                            case LEFT: 
                                //left;
                                if(!context.animated()){
                                    context.move(-1, 0);
                                }
                                break;
                            case UP: 
                                //up;
                                if(!context.animated()){
                                    context.move(0, -1);
                                }
                                break;
                            case RIGHT:
                                //right;
                                if(!context.animated()){
                                    context.move(1, 0);
                                }
                                break;
                            case DOWN:
                                //down;
                                if(!context.animated()){
                                    context.move(0, 1);
                                }
                                break;
                            default:
                                break;
                        }
                    };
                    window.addEventListener('keydown', context.keyListener);
                }
                attach_touch_controls()
                {
                    
                    this.cumulative_movement = {x: 0, y: 0};
                    this.pointer_location = {x: null, y: null};
                    
                    let is_pointer_down = false;
                    let context = this;
                    let offset = {x: Math.floor((width - fieldSize - outlineWidth) / 2), y: Math.floor((height - fieldSize - outlineWidth) / 2)};
                    
                    function reset_cumulative(){
                        context.cumulative_movement.x = 0;
                        context.cumulative_movement.y = 0;  
                    }
                    if (window.PointerEvent) {
                        // Add Pointer Event Listener
                        document.addEventListener('pointerdown', (event) => {
                            is_pointer_down = true;
                            reset_cumulative();
                            context.pointer_location = new Point(event.x, event.y);
                        }, true);
                        document.addEventListener('pointermove', (event) => {
                            let tmp = context.cumulative_movement;
                            context.cumulative_movement = { x: tmp.x + (event.x - context.pointer_location.x), y: tmp.y + (event.y - context.pointer_location.y) };
                            context.pointer_location = {x: event.x, y: event.y};
                            if(is_pointer_down){
                                if(context.cumulative_movement.x > tileSize){
                                    if(!context.animated())
                                        context.move(1, 0);
                                    reset_cumulative();
                                }else if(context.cumulative_movement.y > tileSize){
                                    if(!context.animated())
                                        context.move(0, 1);
                                    reset_cumulative();
                                }else if(context.cumulative_movement.x < -tileSize){
                                    if(!context.animated())
                                        context.move(-1, 0);
                                    reset_cumulative();
                                }else if(context.cumulative_movement.y < -tileSize){
                                    if(!context.animated())
                                        context.move(0, -1);
                                    reset_cumulative();
                            };
                            }
                            


                        }, true);
                        document.addEventListener('pointerup', (event) =>{
                            is_pointer_down = false;
                        }, true);
                        document.addEventListener('pointercancel', (event) => {
                            is_pointer_down = false;
                        }, true);
                    }
                }
                
                
                /*
                 * Method to move the tiles on user input
                 */
                move(horizontal, vertical)
                {
                    //Time of the animation after which new tile can be spawned
                    let maxTime = 0;
                    //"Current" tile is the tile decisions and computations are made relative to
                    let current;
                    if(horizontal < 0 || vertical < 0){
                        current = 0;
                    }
                    else {
                        current = Math.pow(field_xbyx, 2) - 1;
                    }
                    
                    //Finding the first non-null tile 
                    while(this.tiles[current] === null){
                        current -= horizontal + vertical;
                    }
                    //Process the tiles until it turns out next one would be out of range. This marks all tiles have been processed
                    while(this.tiles[current] !== undefined){
                        //Move to the next tile in the parameter specified direction until the selected tile is not empty or out of field borders.
                        let target = current;
                        do{
                            target += horizontal + vertical * field_xbyx;
                        }
                        while(this.tiles[target] === null && 
                        (target % field_xbyx === current % field_xbyx && horizontal === 0 
                        || Math.floor(target / field_xbyx) === Math.floor(current / field_xbyx) && vertical === 0));

                        
                        //Revert the target one tile back against the parameter specified direction and move to the new target
                        tile_logic: if(
                        //If the tile is out of range or is not on the same row/column as the tile logic intends to move
                        typeof this.tiles[target] == 'undefined' 
                        || !(target % field_xbyx === current % field_xbyx && horizontal === 0 
                            || Math.floor(target / field_xbyx) === Math.floor(current / field_xbyx) && vertical === 0) 
                        //otherwise, in case value of not-null target is not the same as the one logic intends to move 
                        || (this.tiles[current].value === this.tiles[target].value ? false : true)
                        //lastly, if target tile has been merged during this move
                        || this.tiles[target].merged){

                            //Move the target tile one position back
                            target -= horizontal + vertical * field_xbyx;
                            //There should be no need to process and animate tiles given that target tile is the same as the one to move
                            if(target === current)
                                break tile_logic;

                            
                            /*100 ms basic animation length + 50 ms per each tile between the original tile and position tile is moved to*/
                            let animation_duration = 100 + ((Math.abs(target - current) % field_xbyx == 0 
                                ? Math.abs(target - current) / field_xbyx : Math.abs(target - current) % field_xbyx) - 1) * 50;
                            
                            //Making the target tile have all the same values as current one and replacing the current tile with null 
                            [this.tiles[target], this.tiles[current]] = [this.tiles[current], this.tiles[target]];

                            this.tiles[target].animate_movement(new Point(Math.round(margin + step * (target % field_xbyx))
                                , Math.round(margin + step * (Math.floor(target / field_xbyx))))
                                , msToFrames(animation_duration));

                            
                            //Updating the time needed to pass before spawning a new tile
                            if(animation_duration > maxTime){
                                maxTime = animation_duration;
                            }
                       }
                        

                        //Moving to and merging with the target tile
                        else if(this.tiles[current].value === this.tiles[target].value){

                            /*50 ms basic animation length + 50 ms per each tile between the original tile and position tile is moved to*/
                            let animation_duration = 75 + ((Math.abs(target - current) % field_xbyx === 0 
                                ? Math.abs(target - current) / field_xbyx : Math.abs(target - current) % field_xbyx) - 1) * 50;
                            
                            
                            //Removing the current tile from the field while still animating it
                            let disconnect = null;
                            [this.tiles[current], disconnect] = [disconnect, this.tiles[current]];
                            (disconnect).animate_movement(new Point(Math.round(margin + step * (target % field_xbyx))
                                , Math.round(margin + step * (Math.floor(target / field_xbyx))))
                                , msToFrames(animation_duration), true);
                            
                            
                            //as well as double the target tile value and animate it with merging animation
                            this.tiles[target].value *= 2;
                            this.tiles[target].merging = true;
                            this.tiles[target].merged = true;
                            setTimeout(()=>{
                                try{
                                    this.tiles[target].animate_merge(msToFrames(100));
                                }
                                catch(error){
                                    console.dir(error);
                                }
                                
                            }, animation_duration);


                            //Update the time needed to pass before spawning a new tile
                            if(animation_duration > maxTime)
                                maxTime = animation_duration + 100;
                        }
                        //Searching for the next tile
                        do{
                            current -= horizontal + vertical;
                        }
                        while(this.tiles[current] === null);

                    }
                    //Resetting the tiles that have been merged on the current move
                    for(let each of this.tiles)
                        if(each !== null)
                            each.merged = false;
                    
                    switch(this.is_game_over()){
                        case 1:

                            break;
                        case 0: 
                            let context = this;
                            if(maxTime !== 0){
                                setTimeout(function(){ context.spawn_tile(msToFrames(100)); }, maxTime);                                
                            }
                                
                            break;
                        case -1: 
                            break;

                    }

                    this.space.play();
                    //setTimeout(space.pause, maxTime + 100);
                    
                }
                

                is_game_over()
                {
                    for(let each of this.tiles)
                        if(each !== null && each.value === 2048)
                        {
                            each.animate_gameover();
                            return 1;
                        }
                    if(this.full()){
                        if(this.no_moves()){
                            return -1;
                        }
                    }
                    return 0;
                }

                //Method to check if there are any moves eligible for making
                no_moves()
                {
                    let passed = [];
                    //helper function to decide whether the compared tiles are valid and equal
                    function ok(context, one, another)
                    {
                        if(typeof context.tiles[another] !== 'undefined'){
                            if(context.tiles[one] === context.tiles[another]){
                                return true;
                            }
                        }
                        return false;
                    }

                    //Compare each tile with its neighbors
                    for(let i = 0; i < 25; ++i){
                        if(ok(this, i, i-1) || ok(this, i, i + 1) || ok(this, i, i - field_xbyx) || ok(this, i, i + field_xbyx)){
                            return false;
                        }
                    }
                    return true;
                }


                //Method to check if the field is filled with tiles completely
                full()
                {
                    for(const any of this.tiles)
                        if(any === null)
                            return false;
                    return true;
                }


                //Method to check if any of the field's tiles are animated
                animated()
                {
                    for(const any of this.tiles)
                        if(any !== null && (any.moving || any.merging || any.gameovering || any.spawning))
                            return true;
                    return false;
                }

                //Create a new tile on the field by selecting a random non-filled tile and creating a new one there
                spawn_tile(frames)
                {
                    let current = null;
                    do{
                        current = Math.floor(Math.random() * 25);
                    }
                    while(this.tiles[current] !== null);
                    this.tiles[current] = new Tile(current, this.space);
                    this.tiles[current].sprite.scale = 0;
                    this.tiles[current].spawning = true;

                    let context = this;
                    let frameStep = 1 / frames;
                    let spawner = function(){

                        if(frames === 0){
                            context.tiles[current].sprite.scale = 1;
                            context.space.unbind('update', spawner);
                            context.space.update();
                            context.tiles[current].spawning = false;
                        }
                        else{
                            --frames;
                            context.tiles[current].sprite.scale += frameStep;
                        }
                    };
                    this.space.bind('update', spawner);
                }

                destroy()
                {
                    this.space = undefined;
                    window.removeEventListener('keydown', this.keyListener);
                    this.keyListener = undefined;
                    for(let each of this.tileSprites){
                        each.remove();
                        each = undefined;
                    }
                    this.tileSprites = undefined;
                    this._field.remove();
                    this._field = undefined;
                    for(let each of this.tiles){
                        if(each !== null){
                            each.destroy();
                        }

                    }
                    this.tiles = undefined;
                }
            };


            class Tile{
                constructor(position, space)
                {
                    this.value = 2;
                    let coords = {x: Math.round(position % field_xbyx * step + margin), y: Math.round(Math.floor(position / field_xbyx) * step + margin)};
                    //Copying drawing space
                    this.space = space;
                    
                    //Defining tile sprite
                    this.sprite = space.makeRoundedRectangle(coords.x, coords.y, tileSize, tileSize);
                    this.sprite.fill = colormap_tile[this.value];
                    this.sprite.stroke = colormap_tile[this.value];

                    //Defining the value displayed over the tile
                    this.message = this.space.makeText(this.value, coords.x, coords.y);
                    this.message.fill = 'teal';
                    this.message.size = Math.floor(tileSize / 3);
                    
                    //Extra flags for the movement logic
                    this.moving = false;
                    this.merging = false;
                    this.merged = false;
                    this.gameovering = false;
                    this.spawning = false;

                }

                //Definition of function that plays upon reaching 2048
                animate_gameover()
                {
                    let context = this;
                    this.gameovering = true;
                    let frameChange = 0.05;

                    let gameover = function()
                    {
                        if(typeof context.final !== 'undefined' && context.final){
                            context.space.unbind('update', gameover);
                            context.moving = false;
                            context.gameovering = false;
                            context.merging = false;
                        }
                        else{
                            context.message.rotation += frameChange;
                        } 
                    };
                    context.space.bind('update', gameover);
                }

                //Animation of tile merging
                animate_merge(framesCount)
                {
                    let context = this;
                    let threshold = Math.round(framesCount / 2);
                    let frameChange = 0.2 / framesCount * 2;
                    this.merging = true;
                    let merge = function(){
                            if(framesCount === 0)
                        {
                            --framesCount;
                            context.sprite.scale = 1;
                            context.message.scale = 1;
                            context.space.unbind('update', merge);
                            context.merging = false;
                        }
                        else{
                            if(framesCount > threshold){
                                context.sprite.scale = context.sprite.scale + frameChange;
                                context.message.scale = context.message.scale + frameChange * 2;
                            }
                            else{
                                context.update();
                                context.sprite.scale = context.sprite.scale - frameChange;
                                context.message.scale = context.message.scale - frameChange * 2;
                            }
                                
                            
                            --framesCount;
                            
                        }
                    }
                    context.space.bind('update', merge);
                }
                
                destroy()
                {
                    this.space = undefined;
                    this.sprite.remove();
                    this.sprite = undefined;
                    this.message.remove();
                    this.message = undefined;
                }
                
                animate_movement(moveTo, framesCount, should_destroy)
                {
                    let frameStep = { x: (moveTo.x - this.sprite.translation.x) / framesCount, y: (moveTo.y - this.sprite.translation.y) / framesCount };
                    let context = this;
                    this.moving = true;
                    let f = function()
                    {
                        if(framesCount === 0){
                            --framesCount;
                            context.sprite.translation.set(moveTo.x, moveTo.y);
                            context.message.translation.set(moveTo.x, moveTo.y);
                            context.space.unbind('update', f);
                            //Not sure this needs to be updated
                            context.moving = false;
                            
                            
                            if(typeof(should_destroy) !== 'undefined'/* && should_destroy*/){
                                context.sprite.remove();
                                context.message.remove();
                                context.destroy();
                            }
                        }
                        else if(framesCount > 0){
                            --framesCount;
                            context.sprite.translation.set(context.sprite.translation.x + frameStep.x, context.sprite.translation.y + frameStep.y);
                            context.message.translation.set(context.sprite.translation.x + frameStep.x, context.sprite.translation.y + frameStep.y);
                        }
                    };
                    this.space.bind('update', f);

                }
                
                update()
                {
                    this.message.value = this.value;
                    this.sprite.fill = colormap_tile[this.value];
                    this.sprite.stroke = colormap_tile[this.value];
                }

            };
            
            //End of definitive script section
        </script>


        <div class="topnav noselect">
        <button class="barButton active" onclick="switch_tab(event, 'eng')">CV</button>
        <button class="barButton" onclick="switch_tab(event, 'home')">Резюме</button>
        <button class="barButton" onclick="switch_tab(event, 'game')">2048</button>
        </div>

        <!--Declaring separate sections for tabs in container-->
        <div class="container">
            <div style="display: block; float: left; margin: 50px 50px 50px 50px; color: #F0F0F0" class = "content" id = "eng">
                <h1 style="text-align: center;" class="green">Nikita Malshakov</h1><br>
                <div class="green">Personal data:</div>
                <span class="blue">Residentship:</span>			Mykolayiv, Bohoyavlensky ave., 28, apt. 18<br>
                <span class="blue">Date of birth:</span>			25.03.1998(22 years)<br>
                <span class="blue">Marital status:</span>			single, no children<br><br>

                <span class="blue">Education:</span> 			    high school graduate<br>
                <span class="blue">University:</span> 			National University of Shipbuilding<br>
                <span class="blue">Specialty:</span>				Computer sciences<br>
                <span class="blue">Certifications:</span>			English level B2 certified  with an FCE certificate<br><br>

                <div class="green">Contact details:</div>
                <span class="blue">Cell phone number:</span>		+38 068 432 80 58<br>
                <span class="blue">E-mail address:</span>			malshakov.n@gmail.com<br>
                <span class="blue">CV website:</span>			<a href="https://notthateasy.github.io">notthateasy.github.io</a><br><br>

                <div class="green">Work expectations:</div>
                <span class="blue">Schedule:</span>				Working in 8-hour shifts.<br>
                <span class="blue">Work experience:</span>	There is a previous experience of year of working in shifts as an English-speaking Customer Support specialist employed with Namecheap. 
                                    Computer vision internship at Chi Software<br><br>
                <div class="green">Knowledge of languages:</div>
                Native Russian and Ukrainian speaker with an assessed English level of B2-C1, whereas B2 level of English is certified with an FCE certificate of grade B. 
                Former Customer Support specialist with fluency in written English (chats and e-mails) as well as skills in Business English necessary when contacting both customers and colleagues.<br><br>
                <div class="green">PC-related hard skills:</div>
                    A Windows 10 user that is acquainted with basic office programs such as Microsoft Word and Excel.
                    Always open to learn about new tools and programming/work environments.
                    There is also an experience of working with Linux Mint as main operating system for the PC as well as advising customers remotely on their machines running Linux or Windows operating systems.
                    Moderately experienced in working with server machines.<br>

                    An experienced user of Kayako chat and ticket system in supporting customers, who also can multitask in order to deliver the customer the best experience possible.
                    Good with the tools required to communicate with the team, e.g. for solving peculiar problems.<br>

                    Student programmer with some experience in such languages as C++ (junior level), and beginner level programmer in such languages as JavaScript, Python, Haskell. 
                    Have completed 20 Project Euler’s problems using all three languages as follows: C++, Python, Haskell.
                    Most experience gained in programming is in the computer graphics field as well as 2D computer gaming one.<br><br>
                <div class="green">Soft skills:</div>
                    A courteous person, able to think under pressure as well as being deadline-oriented and result-driven.<br>
            </div>

            <div style="display: none; float: left; margin: 50px 50px 50px 50px; color: #F0F0F0" class = "content" id = "home">
                <h1 style="text-align: center;" class="green">Мальшаков Никита</h1>
                    
                    <div class="green">Личные данные:</div>
                    <span class="blue">Место проживания:</span> <span class="shifted">г. Николаев, пр. Богоявленский, д. 28</span><br>
                    <span class="blue">Дата рождения:</span> <span class="shifted">25.03.1998(22 полных года)</span><br>
                    <span class="blue">Семейный статус:</span> <span class="shifted">холост, детей нет</span><br>
                    <span class="blue">Образование:</span> <span class="shifted">полное среднее, неоконченное высшее.</span><br>
                    <span class="blue">ВУЗ:</span> <span class="shifted">Национальный аэрокосмический университет им. Н.Е. Жуковского “Харьковский авиационный институт” (завершил учёбу на 4-м курсе).</span><br>
                    <span class="blue">Специальность:</span> <span class="shifted">Компьютерные науки.</span><br>
                    <span class="blue">Доп. образование:</span> <span class="shifted">Курсы английского “My Way”, г. Николаев, где обучался в течение 10 лет.</span><br><br>
    
                    <span class="green">Контактная информация:</span><br>
                    <span class="blue">Контактный телефон:</span> +38 068 432 80 58<br>
                    <span class="blue">Адрес электронной почты:</span> bm.zitter@gmail.com<br><br>
    
                    <span class="blue">Предпочтительный график:</span>	Работа с гибким графиком.<br>
                    <span class="blue">Опыт работы:</span>Интернатура по работе с компьютерным зрением на языке C++ в Chi software, год работы в качестве англоязычного специалиста-консультанта в сфере SSL-сертификации/специалиста по поддержке англоязычных клиентов.<br><br>
                    <span class="green">Знание иностранных языков:</span><br>
                    Родные языки – русский и украинский. Знание английского на уровне Advanced, включая business English; владение языком на уровне B2 подтверждено сертификатом FCE. Занимался курсами английского в течение 10 лет параллельно со школьной программой.<br>
                    <span class="green">Навыки работы с компьютером:</span><br>
                    Работаю в операционной среде Windows 10, владею базисными офисными программами. Присутствует также опыт работы в среде Linux (Mint) в качестве основной ОС, а также Linux-серверами. В случае чего, всегда готов к всестороннему изучению новых окружений и средств. В курсе университетской программы имел опыт обращения с программными продуктами MS Office/LibreOffice, по большей части Word/Writer.<br>
                    Имею опыт работы с SolidWorks на уровне университетского курса, работал с AutoCAD. Имел университетский опыт работы со статистическим анализом данных при помощи компьютерных программ.<br>
                    Тяготею к программированию – пишу на таких языках, как C++ (junior уровень), JavaScript, чистый PHP, Python. Завершил 20 задач из цикла “Project Euler” на языках C++, Python, Haskell.<br>
                    В программировании более всего интересовался и занимался разработкой двумерных игр и компьютерной программируемой графикой.<br>
                    Интерес к C++ и играм подстегнул углубиться в высокопроизводительные, многопоточные вычисления на C++ и, в частности, открытую библиотеку компьютерного зрения OpenCV.<br>
                    Интересуюсь юнит- и авто-тестированиями, хоть и не имел опыта их применения. В курсе основных принципов ООП и руководствуюсь ими в ООП-ориентированных языках и ООП-ориентированных задачах.
                    

            </div>


            <div style = "display: none; touch-action: none;" class = "content active1 noselect" id = "game">
                <div id = "draw" onpointerdown = "startTouch(event, 'draw')">
                    <script>
                    
                        let space = new Two( { width: elementSize, height: elementSize, type: Two.Types.svg} )
                            
                            .appendTo(document.getElementById('game'));
                        
                        let field = null;
                        function makeField(xbyx){
                            setDimensions(xbyx);
                            if(field !== null)
                            {
                                field.destroy();
                                field = undefined;
                            }
                            field = new Field(space);
                            space.update();
                        }
                        console.dir(document);
                        makeField(5);
    
                    </script>
                </div>
            </div>
        </div>
            
        <div class = "bottom_nav" style = "display: none;">
            <button class = "barButton" onclick="makeField(3)">3x3</button>
            <button class = "barButton" onclick="makeField(4)">4x4</button>
            <button class = "barButton" onclick="makeField(5)">5x5</button>
            <button class = "barButton" onclick="makeField(6)">6x6</button>
        </div>
            
                
        
        </div>
        <script>

            let el = document.getElementById('draw');
            
            let switching = 0;

            //console.dir(document.getElementsByClassName('content')[0]);
            function switch_tab(event, tab)
            {
                if(switching){
                    let tabs = document.getElementsByClassName('content');
                    for(let each of tabs){
                        each.style.display = 'none';
                    }    
                }
                ++switching;
                let buttons = document.getElementsByClassName('barButton');
                let tabs = document.getElementsByClassName('content');
                window.scrollbars.visible = false;
                for(let i = 0; i < buttons.length; ++i){
                    if(buttons[i].classList.contains('active')){
                        if(tabs[i] === document.getElementById(tab))
                            continue;
                        buttons[i].classList.remove('active');
                        tabs[i].classList.add('out');
                        setTimeout(() => {
                            if(switching < 2)
                                tabs[i].style.display = 'none';
                            
                            tabs[i].classList.remove('out');
                        }, 300);
                    }
                        
                }
                if(tab !== 'game'){
                    let bottom_nav = document.getElementsByClassName('bottom_nav')[0];
                    bottom_nav.classList.add('bottom_out');
                    setTimeout(() => {
                        bottom_nav.style.display = 'none';
                    }, 250);
                } else {
                    let bottom_nav = document.getElementsByClassName('bottom_nav')[0];
                    bottom_nav.classList.remove('bottom_out');
                    bottom_nav.style.display = 'block';
                }
                document.getElementById(tab).style.display = 'block';
                setTimeout(() => --switching, 500)
                //console.dir(event.currentTarget.classList);
                event.currentTarget.classList.add('active');
            }
        </script>




        
        <script>
            
        </script>
    </body>
</html>
